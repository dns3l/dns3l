#!/bin/bash

# Caution: To feed into cli.sh, but parsed by Argbash...

export BASE
export SCRIPT=$(basename ${0})
export NAME=$(basename -s .sh ${0})
export LOG=${BASE}/${NAME}.log
export VERSION=0.8.1

# DEFINE_SCRIPT_DIR_GNU([BASE])
# INCLUDE_PARSING_CODE([dns3l-cli.sh])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.11.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.dev for more info

# OTHER STUFF GENERATED BY Argbash
BASE="$(cd "$(dirname "$(readlink -e "${BASH_SOURCE[0]}")")" && pwd)" || { echo "Couldn't determine the script's running directory, which probably matters, bailing out" >&2; exit 2; }
. "$BASE/dns3l-cli.sh"  # '.' means 'source'


### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

if [ -n "${MSYSTEM}" ]; then
  _arg_windows=on
fi
if [ -z "${_arg_windows#off}" ]; then
  [ "${FLOCKER}" != "$0" ] && exec env FLOCKER="$0" flock -xn "$0" "$0" "$@" || :
fi

# bash strict mode: http://redsymbol.net/articles/unofficial-bash-strict-mode/
set -euo pipefail
IFS=$'\n\t'

if [[ -f "${_arg_config/#\~/$HOME}" ]]; then
  echo "Loading config ${_arg_config/#\~/$HOME}..." >&2
  . "${_arg_config/#\~/$HOME}"
fi
if [ -n "${_arg_windows#off}" ]; then
  echo "Running on Windows..." >&2
  shopt -s expand_aliases
  if [ -x ${JQ:-"jq-win64.exe"} ]; then
    alias jq=${JQ:-"jq-win64.exe"}
  else
    echo "Oooops. https://stedolan.github.io/jq/ required." >&2
    exit 2
  fi
fi

DNS3L_URL=https://${DNS3L_FQDN:-"localhost"}/api # http://dns3ld:8880/api
AUTH_URL=https://${DNS3L_FQDN:-"localhost"}/auth # https://auth:5554/auth
CLIENT_ID=${CLIENT_ID:-"dns3l-api"}
CLIENT_SECRET=${CLIENT_SECRET:-"secret"}
DAEMON_CLIENT_ID=${DAEMON_CLIENT_ID:-"dns3ld"} # https://github.com/dns3l/dns3l-core/issues/59

AUTH_USER=${DNS3L_USER:-""}
if [ -z "${AUTH_USER}" -a -z "${_arg_anonymous#off}" ]; then
  set +u
  if [ -n "${USERNAME}" ]; then
    AUTH_USER=${USERNAME,,}
  elif [ -n "${USER}" ]; then
    AUTH_USER=${USER,,}
  elif [ -n "${LOGNAME}" ]; then
    AUTH_USER=${LOGNAME,,}
  else
    echo "Oooops. No user found." >&2
    exit 3
  fi
  set -u
fi
AUTH_PASS=${DNS3L_PASS:-""}
if [ -z "${AUTH_PASS}" -a -z "${_arg_anonymous#off}" ]; then
  read -sp "Password for ${AUTH_USER}: " AUTH_PASS
  echo >&2
fi

if [ -z "${_arg_skiptls#off}" ]; then
  CURL_OPTS=( -s )
else
  CURL_OPTS=( -s -k )
fi

if [ -z "${_arg_anonymous#off}" ]; then
  TOKEN_URL=`curl "${CURL_OPTS[@]}" "${AUTH_URL}/.well-known/openid-configuration" | jq -r .token_endpoint || true`
  if [[ -z ${TOKEN_URL} ]]; then
    echo "Oooops. No token URL from ${AUTH_URL}/.well-known/openid-configuration." >&2
    exit 5
  fi
  echo "Feeding ID token for ${AUTH_USER} from ${TOKEN_URL}..." >&2
  ID_TOKEN=`curl "${CURL_OPTS[@]}" -X POST -u "${CLIENT_ID}:${CLIENT_SECRET}" \
    -d "grant_type=password&scope=openid profile email groups offline_access audience:server:client_id:${DAEMON_CLIENT_ID}&username=${AUTH_USER}&password=${AUTH_PASS}" \
    ${TOKEN_URL} | jq -r .id_token`
  if [[ -z ${ID_TOKEN} || ${ID_TOKEN} == "null" ]]; then
    echo "Oooops. Invalid token." >&2
    exit 5
  fi
  echo "ID token for ${AUTH_USER}: ${ID_TOKEN}" >&2
  echo ${ID_TOKEN} | jq -R 'split(".") | .[0] | @base64d | fromjson' >&2 # header
  echo ${ID_TOKEN} | jq -R 'split(".") | .[1] | @base64d | fromjson' >&2 # payload

  AUTH_HEADER=( -H "Authorization: Bearer ${ID_TOKEN}" )
else
  AUTH_HEADER=( )
fi

echo "Ping API..." >&2
curl "${CURL_OPTS[@]}" "${AUTH_HEADER[@]}" ${DNS3L_URL}/info | jq --indent 1 . >&2
echo "Configured CA..." >&2
curl "${CURL_OPTS[@]}" "${AUTH_HEADER[@]}" ${DNS3L_URL}/ca | jq --indent 1 . >&2

function list()
{
  echo "Certs issued by ${1}..." >&2
  curl "${CURL_OPTS[@]}" "${AUTH_HEADER[@]}" ${DNS3L_URL}/ca/${1}/crt | jq --indent 1 .
}

function delete()
{
  echo "Delete ${2}:${1}..." >&2
  curl "${CURL_OPTS[@]}" -X DELETE "${AUTH_HEADER[@]}" ${DNS3L_URL}/ca/${1}/crt/${2} | jq --indent 1 .
}

function get()
{
  echo "${2}:${1} details..." >&2
  curl "${CURL_OPTS[@]}" "${AUTH_HEADER[@]}" ${DNS3L_URL}/ca/${1}/crt/${2} | jq --indent 1 .
  curl "${CURL_OPTS[@]}" "${AUTH_HEADER[@]}" ${DNS3L_URL}/ca/${1}/crt/${2}/pem | jq --indent 1 .
}

function key()
{
  echo "PEM key for ${2}:${1}..." >&2
  curl "${CURL_OPTS[@]}" "${AUTH_HEADER[@]}" ${DNS3L_URL}/ca/${1}/crt/${2}/pem/key | sed -e '/^[[:space:]]*$/d'
}

function crt()
{
  echo "PEM for ${2}:${1}..." >&2
  curl "${CURL_OPTS[@]}" "${AUTH_HEADER[@]}" ${DNS3L_URL}/ca/${1}/crt/${2}/pem/crt | sed -e '/^[[:space:]]*$/d'
}

function chain()
{
  echo "PEM chain for ${2}:${1}..." >&2
  curl "${CURL_OPTS[@]}" "${AUTH_HEADER[@]}" ${DNS3L_URL}/ca/${1}/crt/${2}/pem/chain | sed -e '/^[[:space:]]*$/d'
}

function root()
{
  echo "PEM root for ${2}:${1}..." >&2
  curl "${CURL_OPTS[@]}" "${AUTH_HEADER[@]}" ${DNS3L_URL}/ca/${1}/crt/${2}/pem/root | sed -e '/^[[:space:]]*$/d'
}

function rootchain()
{
  echo "PEM rootchain for ${2}:${1}..." >&2
  curl "${CURL_OPTS[@]}" "${AUTH_HEADER[@]}" ${DNS3L_URL}/ca/${1}/crt/${2}/pem/rootchain | sed -e '/^[[:space:]]*$/d'
}

function fullchain()
{
  echo "PEM fullchain for ${2}:${1}..." >&2
  curl "${CURL_OPTS[@]}" "${AUTH_HEADER[@]}" ${DNS3L_URL}/ca/${1}/crt/${2}/pem/fullchain | sed -e '/^[[:space:]]*$/d'
}

function claim()
{
  function join () {
    local d=${1-} f=${2-}
    if shift 2; then
      printf "%s" "\"$f" "${@/#/\"$d\"}"
      printf "\""
    fi
  }
  if [ -z "${_arg_wildcard#off}" ]; then
    wc=false
  else
    wc=true
  fi
  if [ -n "${_arg_dns}" ]; then
cat <<EOT
{ "name":"${2}", "wildcard":$wc, "autodns":{"ipv4":"${_arg_dns}"}, "san":[$(join , ${_arg_san[@]})] }
EOT
  else
cat <<EOT
{ "name":"${2}", "wildcard":$wc, "san":[$(join , ${_arg_san[@]})] }
EOT
  fi | curl "${CURL_OPTS[@]}" "${AUTH_HEADER[@]}" -X POST \
         -H 'content-type: application/json' \
         -d @- ${DNS3L_URL}/ca/${1}/crt | jq --indent 1 .
}

_cas=()
if (( ${#_arg_ca[@]} > 1 )); then
  # Strip the default...
  for ca in ${_arg_ca[@]:1}; do
    if [[ "${ca,,}" == "any" ]]; then
      _ret=`curl "${CURL_OPTS[@]}" ${DNS3L_URL}/ca | jq -r 'map(.id) | join (",")'`
      readarray -td, _cas <<<"$_ret"
      break
    else
      _cas+=(${ca})
    fi
  done
else
  # The default...
  _cas=${_arg_ca}
fi

case "${_arg_cmd}" in
  list)
    for ca in ${_cas[@]}; do list "$ca"; done
    ;;
  claim)
    for ca in ${_cas[@]}; do claim "$ca" "${_arg_fqdn}"; done
    ;;
  delete)
    for ca in ${_cas[@]}; do delete "$ca" "${_arg_fqdn}"; done
    ;;
  get)
    for ca in ${_cas[@]}; do get "$ca" "${_arg_fqdn}"; done
    ;;
  key)
    for ca in ${_cas[@]}; do key "$ca" "${_arg_fqdn}"; done
    ;;
  crt)
    for ca in ${_cas[@]}; do crt "$ca" "${_arg_fqdn}"; done
    ;;
  chain)
    for ca in ${_cas[@]}; do chain "$ca" "${_arg_fqdn}"; done
    ;;
  fullchain)
    for ca in ${_cas[@]}; do fullchain "$ca" "${_arg_fqdn}"; done
    ;;
  rootchain)
    for ca in ${_cas[@]}; do rootchain "$ca" "${_arg_fqdn}"; done
    ;;
  root)
    for ca in ${_cas[@]}; do root "$ca" "${_arg_fqdn}"; done
    ;;
esac

# THE DEFAULTS INITIALIZATION - POSITIONALS
#_positionals=()
#_arg_cmd=
#_arg_fqdn=
#_arg_san=()
# THE DEFAULTS INITIALIZATION - OPTIONALS
#_arg_ca=(les)
#_arg_dns=
#_arg_wildcard="off"

# ] <-- needed because of Argbash
